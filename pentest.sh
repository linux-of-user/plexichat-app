#!/bin/bash

# PlexiChat Comprehensive Penetration Testing Script
# Author: Security Assessment Tool
# Version: 2.0

set +e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
TARGET_URL="http://localhost:8001"
REPORT_FILE="pentest_report_$(date +%Y%m%d_%H%M%S).md"
TEMP_DIR="/tmp/plexichat_pentest"
mkdir -p "$TEMP_DIR"

# Global variables
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0
CRITICAL_ISSUES=0
HIGH_ISSUES=0
MEDIUM_ISSUES=0
LOW_ISSUES=0

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" | tee -a "$REPORT_FILE"
}

log_success() {
    echo -e "${GREEN}[âœ“]${NC} $1" | tee -a "$REPORT_FILE"
    ((PASSED_TESTS++))
}

log_warning() {
    echo -e "${YELLOW}[âš ]${NC} $1" | tee -a "$REPORT_FILE"
    ((MEDIUM_ISSUES++))
}

log_error() {
    echo -e "${RED}[âœ—]${NC} $1" | tee -a "$REPORT_FILE"
    ((FAILED_TESTS++))
}

log_critical() {
    echo -e "${RED}[ðŸš¨ CRITICAL]${NC} $1" | tee -a "$REPORT_FILE"
    ((CRITICAL_ISSUES++))
}

log_high() {
    echo -e "${PURPLE}[ðŸ”¥ HIGH]${NC} $1" | tee -a "$REPORT_FILE"
    ((HIGH_ISSUES++))
}

test_start() {
    ((TOTAL_TESTS++))
    echo -e "${CYAN}[TEST $TOTAL_TESTS]${NC} $1" | tee -a "$REPORT_FILE"
}

# Utility functions
make_request() {
    local method="$1"
    local endpoint="$2"
    local data="$3"
    local headers="$4"
    
    if [ -n "$data" ]; then
        curl -s -X "$method" -H "Content-Type: application/json" $headers -d "$data" "$TARGET_URL$endpoint" 2>/dev/null
    else
        curl -s -X "$method" $headers "$TARGET_URL$endpoint" 2>/dev/null
    fi
}

check_endpoint() {
    local endpoint="$1"
    local expected_status="$2"
    
    local status=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET_URL$endpoint" 2>/dev/null)
    if [ "$status" = "$expected_status" ]; then
        return 0
    else
        return 1
    fi
}

# Test functions
test_server_availability() {
    test_start "Server Availability Check"
    
    if check_endpoint "/health" "200"; then
        local response=$(make_request "GET" "/health")
        local version=$(echo "$response" | jq -r '.version' 2>/dev/null)
        log_success "Server is running - Version: $version"
    else
        log_critical "Server is not responding at $TARGET_URL"
        exit 1
    fi
}

test_default_credentials() {
    test_start "Default Credentials Test"
    
    # Test common default credentials
    local default_creds=(
        '{"username":"admin","password":"admin"}'
        '{"username":"admin","password":"password"}'
        '{"username":"admin","password":"123456"}'
        '{"username":"root","password":"root"}'
        '{"username":"test","password":"test"}'
    )
    
    for cred in "${default_creds[@]}"; do
        local response=$(make_request "POST" "/auth/auth/login" "$cred")
        if echo "$response" | grep -q "access_token"; then
            local username=$(echo "$cred" | jq -r '.username')
            local password=$(echo "$cred" | jq -r '.password')
            log_critical "DEFAULT CREDENTIALS WORK: $username:$password"
        fi
    done
    
    log_success "Default credentials test completed"
}

test_password_policy() {
    test_start "Password Policy Enforcement"
    
    local weak_passwords=(
        "123"
        "password"
        "test"
        "admin"
        "qwerty"
        "Password123"  # Missing special char
        "password123!" # Missing uppercase
        "PASSWORD123!" # Missing lowercase
        "TestPass!"    # Too short
    )
    
    local weak_count=0
    for pwd in "${weak_passwords[@]}"; do
        local response=$(make_request "POST" "/api/v1/auth/register" \
            "{\"username\":\"testuser$RANDOM\",\"password\":\"$pwd\",\"email\":\"test@example.com\",\"terms_accepted\":true}")
        
        if echo "$response" | grep -q "success.*true"; then
            log_high "WEAK PASSWORD ACCEPTED: $pwd"
            ((weak_count++))
        fi
    done
    
    if [ $weak_count -eq 0 ]; then
        log_success "Password policy properly enforced"
    else
        log_high "Password policy allows $weak_count weak passwords"
    fi
}

test_sql_injection() {
    test_start "SQL Injection Testing"
    
    local sql_payloads=(
        "' OR '1'='1"
        "'; DROP TABLE users; --"
        "' UNION SELECT * FROM users --"
        "admin'--"
        "' OR 1=1 --"
        "'; EXEC xp_cmdshell('dir'); --"
    )
    
    local vulnerable=0
    for payload in "${sql_payloads[@]}"; do
        local response=$(make_request "POST" "/api/v1/auth/login" \
            "{\"username\":\"$payload\",\"password\":\"test\"}")
        
        # Check for SQL error messages or unexpected success
        if echo "$response" | grep -qi "sql\|syntax\|mysql\|postgresql\|database\|table"; then
            log_critical "SQL INJECTION VULNERABILITY: $payload"
            ((vulnerable++))
        elif echo "$response" | grep -q "access_token"; then
            log_critical "SQL INJECTION BYPASS: $payload"
            ((vulnerable++))
        fi
    done
    
    if [ $vulnerable -eq 0 ]; then
        log_success "No SQL injection vulnerabilities found"
    fi
}

test_xss_vulnerabilities() {
    test_start "Cross-Site Scripting (XSS) Testing"
    
    local xss_payloads=(
        "<script>alert('XSS')</script>"
        "javascript:alert('XSS')"
        "<img src=x onerror=alert('XSS')>"
        "';alert('XSS');//"
        "<svg onload=alert('XSS')>"
    )
    
    local vulnerable=0
    for payload in "${xss_payloads[@]}"; do
        local response=$(make_request "POST" "/api/v1/auth/register" \
            "{\"username\":\"$payload\",\"password\":\"TestPass123!\",\"email\":\"test@example.com\",\"terms_accepted\":true}")
        
        if echo "$response" | grep -F "$payload" | grep -v "escaped\|encoded"; then
            log_high "XSS VULNERABILITY: Payload reflected unescaped"
            ((vulnerable++))
        fi
    done
    
    if [ $vulnerable -eq 0 ]; then
        log_success "No XSS vulnerabilities found"
    fi
}

test_rate_limiting() {
    test_start "Rate Limiting Testing"
    
    log_info "Testing login endpoint rate limiting..."
    local blocked=0
    
    for i in {1..20}; do
        local response=$(make_request "POST" "/api/v1/auth/login" \
            "{\"username\":\"testuser\",\"password\":\"wrongpass\"}")
        
        if echo "$response" | grep -qi "rate.limit\|too.many\|blocked"; then
            log_success "Rate limiting activated after $i attempts"
            blocked=1
            break
        fi
        sleep 0.1
    done
    
    if [ $blocked -eq 0 ]; then
        log_high "NO RATE LIMITING: Login endpoint allows unlimited attempts"
    fi
}

test_directory_traversal() {
    test_start "Directory Traversal Testing"
    
    local traversal_payloads=(
        "../../../etc/passwd"
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
        "....//....//....//etc/passwd"
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
    )
    
    local vulnerable=0
    for payload in "${traversal_payloads[@]}"; do
        local response=$(make_request "GET" "/api/v1/files/$payload")
        
        if echo "$response" | grep -q "root:\|admin:\|bin:"; then
            log_critical "DIRECTORY TRAVERSAL: $payload"
            ((vulnerable++))
        fi
    done
    
    if [ $vulnerable -eq 0 ]; then
        log_success "No directory traversal vulnerabilities found"
    fi
}

test_information_disclosure() {
    test_start "Information Disclosure Testing"
    
    local info_endpoints=(
        "/.env"
        "/config"
        "/admin"
        "/debug"
        "/api/v1/admin"
        "/swagger.json"
        "/openapi.json"
        "/.git/config"
        "/backup"
        "/logs"
    )
    
    local disclosed=0
    for endpoint in "${info_endpoints[@]}"; do
        local response=$(make_request "GET" "$endpoint")
        
        if echo "$response" | grep -qi "password\|secret\|key\|token\|database\|config"; then
            log_high "INFORMATION DISCLOSURE: $endpoint reveals sensitive data"
            ((disclosed++))
        fi
    done
    
    if [ $disclosed -eq 0 ]; then
        log_success "No information disclosure found"
    fi
}

test_authentication_bypass() {
    test_start "Authentication Bypass Testing"

    local bypass_attempts=(
        '{"username":"admin","password":""}'
        '{"username":"","password":"admin"}'
        '{"username":null,"password":"admin"}'
        '{"username":"admin","password":null}'
    )

    local bypassed=0
    for attempt in "${bypass_attempts[@]}"; do
        local response=$(make_request "POST" "/api/v1/auth/login" "$attempt")

        if echo "$response" | grep -q "access_token"; then
            log_critical "AUTHENTICATION BYPASS: $attempt"
            ((bypassed++))
        fi
    done

    if [ $bypassed -eq 0 ]; then
        log_success "No authentication bypass vulnerabilities found"
    fi
}

test_jwt_security() {
    test_start "JWT Token Security Testing"

    # Get a valid token first
    local login_response=$(make_request "POST" "/api/v1/auth/login" \
        '{"username":"newuser2","password":"NewPassword123!"}')
    local token=$(echo "$login_response" | jq -r '.access_token' 2>/dev/null)

    if [ "$token" != "null" ] && [ -n "$token" ]; then
        log_info "Testing JWT token: ${token:0:20}..."

        # Test with modified token
        local modified_token="${token}modified"
        local response=$(make_request "GET" "/api/v1/auth/me" "" "-H 'Authorization: Bearer $modified_token'")

        if echo "$response" | grep -q "id.*username"; then
            log_critical "JWT SIGNATURE NOT VERIFIED: Modified token accepted"
        else
            log_success "JWT signature properly verified"
        fi

        # Test token without signature
        local unsigned_token=$(echo "$token" | cut -d'.' -f1,2)
        response=$(make_request "GET" "/api/v1/auth/me" "" "-H 'Authorization: Bearer $unsigned_token.'")

        if echo "$response" | grep -q "id.*username"; then
            log_critical "JWT ACCEPTS UNSIGNED TOKENS"
        else
            log_success "JWT requires valid signature"
        fi
    else
        log_warning "Could not obtain valid JWT token for testing"
    fi
}

test_cors_configuration() {
    test_start "CORS Configuration Testing"

    local response=$(curl -s -H "Origin: https://evil.com" \
        -H "Access-Control-Request-Method: POST" \
        -H "Access-Control-Request-Headers: Content-Type" \
        -X OPTIONS "$TARGET_URL/api/v1/auth/login" -I)

    if echo "$response" | grep -qi "access-control-allow-origin.*\*"; then
        log_high "CORS MISCONFIGURATION: Allows all origins (*)"
    elif echo "$response" | grep -qi "access-control-allow-origin.*evil.com"; then
        log_high "CORS MISCONFIGURATION: Allows arbitrary origins"
    else
        log_success "CORS properly configured"
    fi
}

test_api_versioning() {
    test_start "API Versioning Security"

    local versions=("v0" "v2" "v3" "beta" "test" "dev")
    local exposed=0

    for version in "${versions[@]}"; do
        if check_endpoint "/api/$version/auth/login" "200"; then
            log_warning "EXPOSED API VERSION: /api/$version/ is accessible"
            ((exposed++))
        fi
    done

    if [ $exposed -eq 0 ]; then
        log_success "No unauthorized API versions exposed"
    fi
}

test_file_upload_security() {
    test_start "File Upload Security Testing"

    # Test if file upload endpoints exist
    local upload_endpoints=("/api/v1/files/upload" "/upload" "/api/v1/upload")
    local found=0

    for endpoint in "${upload_endpoints[@]}"; do
        local status=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET_URL$endpoint" 2>/dev/null)
        if [ "$status" != "404" ]; then
            log_info "File upload endpoint found: $endpoint (Status: $status)"
            ((found++))

            # Test malicious file upload (if endpoint exists)
            if [ "$status" = "200" ] || [ "$status" = "405" ]; then
                log_warning "FILE UPLOAD ENDPOINT EXPOSED: $endpoint"
            fi
        fi
    done

    if [ $found -eq 0 ]; then
        log_success "No exposed file upload endpoints found"
    fi
}

test_session_management() {
    test_start "Session Management Testing"

    # Test session fixation
    local response1=$(make_request "POST" "/api/v1/auth/login" \
        '{"username":"newuser2","password":"NewPassword123!"}')
    local token1=$(echo "$response1" | jq -r '.access_token' 2>/dev/null)
    local session1=$(echo "$response1" | jq -r '.session_id' 2>/dev/null)

    sleep 1

    local response2=$(make_request "POST" "/api/v1/auth/login" \
        '{"username":"newuser2","password":"NewPassword123!"}')
    local token2=$(echo "$response2" | jq -r '.access_token' 2>/dev/null)
    local session2=$(echo "$response2" | jq -r '.session_id' 2>/dev/null)

    if [ "$token1" = "$token2" ] && [ "$token1" != "null" ]; then
        log_high "SESSION FIXATION: Same token returned for multiple logins"
    elif [ "$session1" = "$session2" ] && [ "$session1" != "null" ]; then
        log_high "SESSION FIXATION: Same session ID returned for multiple logins"
    else
        log_success "Session management properly implemented"
    fi
}

generate_report() {
    echo "" | tee -a "$REPORT_FILE"
    echo "# PlexiChat Security Assessment Report" | tee -a "$REPORT_FILE"
    echo "Generated: $(date)" | tee -a "$REPORT_FILE"
    echo "Target: $TARGET_URL" | tee -a "$REPORT_FILE"
    echo "" | tee -a "$REPORT_FILE"

    echo "## Executive Summary" | tee -a "$REPORT_FILE"
    echo "- **Total Tests**: $TOTAL_TESTS" | tee -a "$REPORT_FILE"
    echo "- **Passed**: $PASSED_TESTS" | tee -a "$REPORT_FILE"
    echo "- **Failed**: $FAILED_TESTS" | tee -a "$REPORT_FILE"
    echo "" | tee -a "$REPORT_FILE"

    echo "## Vulnerability Summary" | tee -a "$REPORT_FILE"
    echo "- **ðŸš¨ Critical**: $CRITICAL_ISSUES" | tee -a "$REPORT_FILE"
    echo "- **ðŸ”¥ High**: $HIGH_ISSUES" | tee -a "$REPORT_FILE"
    echo "- **âš  Medium**: $MEDIUM_ISSUES" | tee -a "$REPORT_FILE"
    echo "- **â„¹ Low**: $LOW_ISSUES" | tee -a "$REPORT_FILE"
    echo "" | tee -a "$REPORT_FILE"

    local total_issues=$((CRITICAL_ISSUES + HIGH_ISSUES + MEDIUM_ISSUES + LOW_ISSUES))
    if [ $total_issues -eq 0 ]; then
        echo "ðŸŽ‰ **EXCELLENT**: No security vulnerabilities found!" | tee -a "$REPORT_FILE"
    elif [ $CRITICAL_ISSUES -gt 0 ]; then
        echo "ðŸš¨ **CRITICAL**: Immediate action required!" | tee -a "$REPORT_FILE"
    elif [ $HIGH_ISSUES -gt 0 ]; then
        echo "ðŸ”¥ **HIGH RISK**: Address high-priority issues soon" | tee -a "$REPORT_FILE"
    else
        echo "âš  **MEDIUM RISK**: Review and address identified issues" | tee -a "$REPORT_FILE"
    fi

    echo "" | tee -a "$REPORT_FILE"
    echo "Report saved to: $REPORT_FILE" | tee -a "$REPORT_FILE"
}

# Main execution
main() {
    echo -e "${CYAN}ðŸ”’ PlexiChat Comprehensive Penetration Test${NC}"
    echo -e "${CYAN}============================================${NC}"
    echo ""

    # Initialize report
    echo "# PlexiChat Penetration Test Log" > "$REPORT_FILE"
    echo "Started: $(date)" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"

    # Run all tests
    test_server_availability
    test_default_credentials
    test_password_policy
    test_sql_injection
    test_xss_vulnerabilities
    test_rate_limiting
    test_directory_traversal
    test_information_disclosure
    test_authentication_bypass
    test_jwt_security
    test_cors_configuration
    test_api_versioning
    test_file_upload_security
    test_session_management

    # Generate final report
    echo ""
    echo -e "${CYAN}Generating final report...${NC}"
    generate_report

    # Cleanup
    rm -rf "$TEMP_DIR"

    echo ""
    echo -e "${GREEN}Penetration test completed!${NC}"
    echo -e "${BLUE}Report: $REPORT_FILE${NC}"
}

# Check dependencies
if ! command -v curl &> /dev/null; then
    echo "Error: curl is required but not installed."
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed."
    exit 1
fi

# Run the main function
main "$@"
